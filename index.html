<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GRAV1TY MAN</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Gravity-Man CSS - Rabbit r1 Pure Viewport Mode */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body, html {
            /* Fixed dimensions for the r1 view (240x282) */
            width: 240px;
            height: 282px;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            touch-action: none;
            font-family: 'Press Start 2P', monospace;
        }

        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        #game-container {
            width: 240px;
            height: 282px;
            position: relative;
            box-shadow: none;
            border: none;
            overflow: hidden;
        }

        /* HUD Styling: with central music button */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 16px;
            padding: 2px;
            color: #ff6600; /* Rabbit r1 Orange */
            background: rgba(0, 0, 0, 0.9);
            font-size: 0.4rem;
            display: flex;
            justify-content: space-between; /* Distributes the three elements */
            align-items: center;
            z-index: 100;
            border-bottom: 1px solid #ff6600;
        }
       
        #hud-music {
            cursor: pointer;
            line-height: 1;
            text-align: center;
            user-select: none;
            /* Small container for the SVG */
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
       
        /* Ensure the SVG is small and styled */
        #music-icon {
            width: 12px;
            height: 12px;
            stroke: #ff6600;
        }

        #gameCanvas {
            display: block;
            width: 240px;
            height: 282px;
            margin: 0;
            padding: 0;
            border: none;
            position: absolute;
            top: 0;
            left: 0;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        /* Overlay Styles */
        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            z-index: 150;
        }

        /* Default positioning for splash/end/loading: pushed down by HUD, centered on content top */
        #splash-screen, #end-screen, #loading-screen {
            height: calc(100% - 16px);
            top: 16px;
            justify-content: flex-start;
            padding-top: 40px;
        }

        /* Specific positioning for GAME OVER: centered in the game area */
        #game-over-message {
            height: calc(100% - 16px);
            top: 16px;
            justify-content: center; /* Centers vertically in the game area */
            padding-top: 0;
        }
       
        .overlay-title {
            font-size: 0.8rem;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 4px white;
        }
       
        /* Game Over Title Color - Rabbit Orange */
        #game-over-message .overlay-title {
            color: #ff6600;
            text-shadow: 0 0 10px rgba(255, 102, 0, 0.8), 0 0 2px #ff6600;
        }

        .overlay-text {
            font-size: 0.5rem;
            margin-top: 0.5rem;
            cursor: pointer;
            animation: blink 1s step-end infinite;
        }

        @keyframes blink {
            50% { opacity: 0.1; }
        }
    </style>
</head>
<body>

<div id="game-container">
    <audio id="game-music" src="https://raw.githubusercontent.com/atomlabor/grav1ty-man-v2/main/Pixel_Dreamers.mp3" loop preload="auto"></audio>

    <div id="hud">
        <div id="hud-level">LEVEL 1: Start</div>
       
        <div id="hud-music" onclick="toggleMusic()">
            <svg id="music-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="#ff6600" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="w-3 h-3">
                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                <path id="sound-waves" d="M15.54 8.46a5 5 0 0 1 0 7.07M19.07 4.93a10 10 0 1 0 0 14.14"></path>
                <line id="mute-slash" x1="1" y1="23" x2="23" y2="1" style="display:none;"></line>
            </svg>
        </div>
       
        <div id="hud-items">G: DOWN | KEY: 0/8</div>
    </div>
   
    <canvas id="gameCanvas" width="240" height="282"></canvas>
   
    <div id="loading-screen" class="game-overlay">
        <div class="overlay-title">LOADING GAME...</div>
        <div id="loading-progress" class="text-white text-xs mt-2">0%</div>
    </div>

    <div id="splash-screen" class="game-overlay hidden" onclick="startGame()">
        <img id="splash-img" src="https://raw.githubusercontent.com/atomlabor/grav1ty-man-v2/main/grav1tyman-splash.png" class="w-1/2 h-auto mb-4">
       
        <div class="text-white text-[0.6rem] mt-4 mb-4 text-center leading-tight">
            tilt to move. tap to flip gravity. collect 8 key parts across 5 rooms to fix your starship.
        </div>
       
        <div class="overlay-text">TAP TO START</div>
    </div>

    <div id="end-screen" class="game-overlay hidden">
        <img id="end-img" src="https://raw.githubusercontent.com/atomlabor/grav1ty-man-v2/main/endscreen.png" alt="End Screen" class="w-1/2 h-auto mb-4">
        <div class="overlay-title">MISSION COMPLETE!</div>
        <div class="text-white text-xs mt-2">your starship is fixed</div>
        <div class="overlay-text" onclick="location.reload()">PLAY AGAIN</div>
    </div>

    <div id="game-over-message" class="game-overlay hidden">
        <div class="overlay-title">TRY AGAIN!</div>
        <div class="text-white text-xs mt-2">restarting shortly...</div>
    </div>

</div>

<script>
    // --- CONFIGURATION & STATE ---
    const CANVAS_WIDTH = 240;
    const CANVAS_HEIGHT = 282;
    const HUD_HEIGHT = 16;   
    const GAME_AREA_HEIGHT = CANVAS_HEIGHT - HUD_HEIGHT;
   
    const NUM_LEVELS = 5; // Total number of levels
    const REQUIRED_ITEMS = 8;
    // MODIFIED: TILE_SIZE changed from 16 to 8
    const TILE_SIZE = 8;
   
    // Player must start at least 32px (4 tiles) away from any enemy (64px / 2)
    const START_SAFE_DISTANCE = 32; 


    let gameState = 'loading';
    let currentLevel = 0;
    let lastTime = 0;
    let gameLoopRunning = false;

    // Gyro & Keyboard State
    let gyroTilt = 0; // Wichtig: Wird durch das Gyroskop (r1-Hardware) gesetzt.
    let keyboardTilt = 0;
    const MAX_TILT_DEGREE = 20;
    const KEYBOARD_ACCEL_FACTOR = 0.5;
   
    // HÖHERER WERT: Gegner reagieren stärker auf die Neigung des Geräts.
    const ENEMY_GYRO_INFLUENCE = 1.5;
   
    let isMusicMuted = false; // State for music control

    // Game Objects
    const player = {
        // MODIFIED: width/height set to new TILE_SIZE
        x: TILE_SIZE, y: TILE_SIZE * 5, width: TILE_SIZE, height: TILE_SIZE,
        velX: 0, velY: 0,
        accelX: 0,
        maxSpeed: 3,
        isGrounded: false,
        isDead: false,
        isGravityUp: false
    };

    const gravity = 0.3;
    const friction = 0.8;


    // DOM Elements
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const loadingScreen = document.getElementById('loading-screen');
    const loadingProgress = document.getElementById('loading-progress');
    const splashScreen = document.getElementById('splash-screen');
    const endScreen = document.getElementById('end-screen');
    const gameOverMessage = document.getElementById('game-over-message');
    const hudLevel = document.getElementById('hud-level');
    const hudItems = document.getElementById('hud-items');
    const hudMusic = document.getElementById('hud-music');
   
    // SVG Elements for Music Toggle
    let soundWaves, muteSlash;

    const splashImg = document.getElementById('splash-img');
    const endImg = document.getElementById('end-img');
   
    // Assets and Audio
    const assets = {};
    const assetUrls = {
        player: 'https://raw.githubusercontent.com/atomlabor/grav1ty-man-v2/main/grav1tyman-player.png',
        background: 'https://raw.githubusercontent.com/atomlabor/grav1ty-man-v2/main/spaceship-bg.png',
        enemy: 'https://raw.githubusercontent.com/atomlabor/grav1ty-man-v2/main/dalek.png',
        item: 'https://raw.githubusercontent.com/atomlabor/grav1ty-man-v2/main/keycard.png',
        exit: 'https://raw.githubusercontent.com/atomlabor/grav1ty-man-v2/main/exit.png',
        splash: 'https://raw.githubusercontent.com/atomlabor/grav1ty-man-v2/main/grav1tyman-splash.png',
        end: 'https://raw.githubusercontent.com/atomlabor/grav1ty-man-v2/main/endscreen.png'
    };
    let audioContext, oscillator;
    let gameMusic;

    // --- LEVEL DEFINITIONS (SCALED FOR TILE_SIZE=8) ---
    // All coordinates and dimensions are divided by 2 compared to the original TILE_SIZE=16.
    // The player, enemies, items, and exit are placed *outside* the platform blocks.
   
    const originalLevelData = [
        // Level 1: Beginner's Trap (Bottom Start)
        {
            platforms: [
                [0, 129, 240, TILE_SIZE], // Floor (Y=258 / 2 = 129)
                [0, 0, TILE_SIZE, 133], // Left Wall (Height 266 / 2 = 133)
                [116, 0, TILE_SIZE, 133], // Right Wall (232 / 2 = 116)
               
                // Platforms
                [40, 92, 40, TILE_SIZE], // (80, 184) / 2
                [80, 92, 36, TILE_SIZE], // (160, 184, 72) / 2
                [0, 62, 75, TILE_SIZE], // (0, 124, 150) / 2
                [90, 32, 26, TILE_SIZE], // (180, 64, 52) / 2
                [20, 32, 50, TILE_SIZE], // (40, 64, 100) / 2
                [0, 2, 20, TILE_SIZE] // Exit Platform (Y=4 / 2 = 2)
            ],
            items: [
                // Y-coordinates are TILE_SIZE/2 (4px) above the platform blocks to simulate being "on" them.
                { x: 5, y: 125, collected: false }, { x: 115, y: 125, collected: false }, // Floor (129-4)
                { x: 5, y: 88, collected: false }, { x: 115, y: 88, collected: false }, // Below P2
                { x: 5, y: 58, collected: false }, { x: 70, y: 58, collected: false }, // Below P3
                { x: 5, y: 28, collected: false }, { x: 115, y: 28, collected: false } // Below P4/P5
            ],
            enemies: [
                // Enemies are placed on the platform and move on it.
                // Y=92 is the platform top. Enemy y should be 92-8 = 84 (Enemy bottom on platform top)
                // Min/Max X scaled: 80/2=40, 152/2=76
                { x: 45, y: 84, dx: 0.8, minX: 40, maxX: 76, minY: 0, isVertical: false, initialX: 45, initialY: 84 }
            ],
            exit: { x: 5, y: 2-8, open: false }, // Exit just above the exit platform (Y=2)
            playerStart: { x: 60, y: 121 }, // START BOTTOM (129 - TILE_SIZE)
            title: "Beginner's Trap"
        },
        // Level 2: Vertical Drop
        {
            platforms: [
                [0, 129, 240, TILE_SIZE], // Floor
                [0, 0, TILE_SIZE, 133], // Left Wall
                [116, 0, TILE_SIZE, 133], // Right Wall
               
                [20, 102, 80, TILE_SIZE], // (40, 204) / 2
                [20, 72, 80, TILE_SIZE], // (40, 144) / 2
                [20, 42, 80, TILE_SIZE], // (40, 84) / 2
               
                [105, 0, 11, TILE_SIZE], // (210, 0, 22) / 2
            ],
            items: [
                { x: 10, y: 125, collected: false }, { x: 110, y: 125, collected: false },
                { x: 110, y: 98, collected: false }, { x: 25, y: 68, collected: false },
                { x: 110, y: 38, collected: false }, { x: 25, y: 0, collected: false },
                { x: 5, y: 68, collected: false }, { x: 110, y: 0, collected: false }
            ],
            enemies: [
                // Vertical (184/2=92, 94/2=47, 194/2=97). Enemy on platform (y: 92-8=84)
                { x: 60, y: 84, dy: 1.2, minY: 47, maxY: 97, isVertical: true, initialY: 84, initialX: 60 },
                // Horizontal (250/2=125). Enemy on floor (y: 129-8=121)
                { x: 5, y: 121, dx: 1.5, minX: 4, maxX: 116, minY: 0, isVertical: false, initialX: 5, initialY: 121 }
            ],
            exit: { x: 105, y: 0, open: false }, // Exit at (210/2=105, 5/2=2, use 0)
            playerStart: { x: 60, y: 121 },
            title: "Vertical Drop"
        },
        // Level 3: Central Shaft
        {
            platforms: [
                [0, 129, 240, TILE_SIZE], // Floor
                [0, 0, TILE_SIZE, 133], // Left Wall
                [116, 0, TILE_SIZE, 133], // Right Wall
               
                [0, 102, 55, TILE_SIZE], [65, 102, 55, TILE_SIZE], // P1 (204/2=102, 110/2=55, gap 20/2=10)
                [0, 72, 55, TILE_SIZE], [65, 72, 55, TILE_SIZE], // P2 (144/2=72)
                [0, 42, 55, TILE_SIZE], [65, 42, 55, TILE_SIZE], // P3 (84/2=42)
               
                [25, -2, 15, TILE_SIZE], // (50, -4, 30) / 2
                [80, -2, 15, TILE_SIZE], // (160, -4, 30) / 2
            ],
            items: [
                { x: 5, y: 125, collected: false }, { x: 115, y: 125, collected: false }, // Floor
                { x: 60, y: 98, collected: false }, // Above P1 gap
                { x: 60, y: 68, collected: false }, // Above P2 gap 
                { x: 5, y: 68, collected: false }, { x: 115, y: 68, collected: false }, // P2 side items
                { x: 60, y: 38, collected: false }, // Above P3 gap
                { x: 30, y: 2, collected: false }, // Top left platform
                { x: 85, y: 2, collected: false } // Top right platform
            ],
            enemies: [
                // Horizontal on floor. Min/Max X scaled: 10/2=5, 220/2=110. Y on floor (129-8=121)
                { x: 12, y: 121, dx: 0.5, minX: 5, maxX: 110, minY: 0, isVertical: false, initialX: 5, initialY: 121 },
                // Vertical in central shaft (134/2=67, 94/2=47, 194/2=97). X: 115/2=57.5, use 58.
                { x: 58, y: 89, dy: 1.5, minY: 47, maxY: 97, isVertical: true, initialY: 97, initialX: 58 }
            ],
            exit: { x: 58, y: 0, open: false }, // Central exit, accessible from the top gap
            playerStart: { x: 110, y: 113 }, // (220/2=110, 220/2=110 -> 129-16)
            title: "Central Shaft"
        },
        // Level 4: Ceiling Start
        {
            platforms: [
                [0, 129, 240, TILE_SIZE], // Floor
                [0, 0, TILE_SIZE, 133], // Left Wall
                [116, 0, TILE_SIZE, 133], // Right Wall
               
                [20, 25, 40, TILE_SIZE], // Start Platform (50/2=25, 80/2=40)
                [80, 50, 36, TILE_SIZE], // (100/2=50, 72/2=36)
                [0, 75, 50, TILE_SIZE], // (150/2=75, 100/2=50)
                [65, 100, 25, TILE_SIZE] // (200/2=100, 50/2=25)
            ],
            items: [
                { x: 5, y: 125, collected: false }, { x: 115, y: 125, collected: false },
                { x: 5, y: 96, collected: false }, { x: 85, y: 96, collected: false },
                { x: 5, y: 21, collected: false }, { x: 80, y: 46, collected: false },
                { x: 5, y: 71, collected: false }, { x: 115, y: 71, collected: false }
            ],
            enemies: [
                // Vertical enemy (240/2=120, 150/2=75, 250/2=125). Y on floor (129-8=121)
                { x: 60, y: 121, dy: 1.5, minY: 75, maxY: 121, isVertical: true, initialY: 121, initialX: 60 }
            ],
            exit: { x: 110, y: 0, open: false }, // Exit at (220/2=110)
            playerStart: { x: 30, y: 17 }, // (60/2=30, 42/2=21 -> 25-8=17)
            title: "Ceiling Start"
        },
        // Level 5: Middle Start
        {
            platforms: [
                [0, 129, 240, TILE_SIZE], // Floor
                [0, 0, TILE_SIZE, 133], // Left Wall
                [116, 0, TILE_SIZE, 133], // Right Wall
               
                [0, 80, 110, TILE_SIZE], // Wide middle platform (160/2=80, 220/2=110)
                [25, 50, 70, TILE_SIZE], // (100/2=50, 140/2=70)
                [5, 20, 110, TILE_SIZE] // (40/2=20, 220/2=110)
            ],
            items: [
                { x: 5, y: 125, collected: false }, { x: 115, y: 125, collected: false },
                { x: 5, y: 76, collected: false }, { x: 115, y: 76, collected: false },
                { x: 5, y: 46, collected: false }, { x: 115, y: 46, collected: false },
                { x: 5, y: 16, collected: false }, { x: 115, y: 16, collected: false }
            ],
            enemies: [
                // Horizontal enemy (160/2=80). Y on platform (80-8=72). Min/Max X: 10/2=5, 220/2=110.
                { x: 5, y: 72, dx: 1, minX: 5, maxX: 110, minY: 0, isVertical: false, initialX: 5, initialY: 72 },
                // Vertical enemy (92/2=46). Min/Max Y: 50/2=25, 140/2=70. X: 120/2=60.
                { x: 60, y: 46, dy: 1, minY: 25, maxY: 70, isVertical: true, initialY: 46, initialX: 60 }
            ],
            exit: { x: 60, y: 0, open: false },
            playerStart: { x: 60, y: 72 }, // (160/2=80, 152/2=76 -> 80-8=72)
            title: "Middle Start"
        }
    ];

    let currentLevelData = [];

    // --- FUNCTIONS ---
   
    // Utility function for distance calculation
    function distance(x1, y1, x2, y2) {
        return Math.hypot(x2 - x1, y2 - y1);
    }

    // Asset Loading
    function loadAssets() {
        const totalAssets = Object.keys(assetUrls).length;
        let loadedCount = 0;
       
        soundWaves = document.getElementById('sound-waves');
        muteSlash = document.getElementById('mute-slash');
       
        const handleAssetLoad = (key, img) => {
            assets[key] = img;
            loadedCount++;
            loadingProgress.textContent = `${Math.round((loadedCount / totalAssets) * 100)}%`;
           
            if (loadedCount === totalAssets) {
                setupAudio();
               
                if (!assets.splash.isFallback) splashImg.src = assets.splash.src;
                if (!assets.end.isFallback) endImg.src = assets.end.src;
               
                loadingScreen.classList.add('hidden');
                splashScreen.classList.remove('hidden');
                gameState = 'splash';
               
               
                if (isMusicMuted) {
                    soundWaves.style.display = 'none';
                    muteSlash.style.display = 'block';
                } else {
                    soundWaves.style.display = 'block';
                    muteSlash.style.display = 'none';
                }
            }
        };

        for (const key in assetUrls) {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => handleAssetLoad(key, img);
            img.onerror = () => {
                console.error(`Error loading asset: ${assetUrls[key]}. Using fallback.`);
                assets[key] = { src: assetUrls[key], isFallback: true };
                handleAssetLoad(key, img);
            };
            img.src = assetUrls[key];
        }
    }
   
    // Audio Setup
    const flipTune = [1000, 1500];
    const noteDuration = 100;
   
    function setupAudio() {
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            console.warn('Web Audio API is not supported.');
        }
        gameMusic = document.getElementById('game-music');
    }

    function playNote(freq) {
        if (!audioContext || audioContext.state === 'suspended' || isMusicMuted) return;
        let oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.type = 'square';
        oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);

        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(0.5, audioContext.currentTime + 0.01);
        gainNode.gain.linearRampToValueAtTime(0.0, audioContext.currentTime + (noteDuration / 1000));

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.start();
        oscillator.stop(audioContext.currentTime + (noteDuration / 1000));
    }
   
    function playFlipTune() {
        if (isMusicMuted) return; // No sound effect if muted
        if (!audioContext || audioContext.state === 'suspended') return;
        flipTune.forEach((freq, index) => {
            setTimeout(() => playNote(freq), index * 50);
        });
    }

    // Toggle music mute/play state
    function toggleMusic() {
        if (!gameMusic) return;

        isMusicMuted = !isMusicMuted;
       
        if (isMusicMuted) {
            gameMusic.pause();
            // Update SVG: Hide waves, show slash
            if (soundWaves) soundWaves.style.display = 'none';
            if (muteSlash) muteSlash.style.display = 'block';
        } else {
            // Only attempt to play if the game is active (not on splash)
            if (gameState !== 'splash') {
                // This ensures play() is called after a user interaction
                gameMusic.play().catch(e => console.warn('Audio could not be started.'));
            }
            // Update SVG: Show waves, hide slash
            if (soundWaves) soundWaves.style.display = 'block';
            if (muteSlash) muteSlash.style.display = 'none';
        }
    }
   
    // Level Logic
    function loadLevel(levelIndex) {
        currentLevel = levelIndex;
        if (currentLevel >= NUM_LEVELS) {
            showEndScreen();
            return;
        }
       
        const original = originalLevelData[currentLevel];
        // Deep clone to ensure enemies/items reset properly
        let level = JSON.parse(JSON.stringify(original));
        currentLevelData = level;

        // ADD MANDATORY TOP BOUNDARY (CEILING)
        // Note: The level data already contains a [0, 0, TILE_SIZE, 133] (Left Wall) and [0, 2, 20, TILE_SIZE] (Platform)
        // Adding the full top boundary here using the new TILE_SIZE=8
        level.platforms.push([0, 0, CANVAS_WIDTH, TILE_SIZE]); // Y=0, Height=8

        // 1. Apply vertical shift (HUD_HEIGHT) to all game elements
        // This is crucial for shifting the game content below the 16px HUD.
        level.platforms = level.platforms.map(p => {
            if (Array.isArray(p)) {
                return [p[0], p[1] + HUD_HEIGHT, p[2], p[3]];
            } else {
                p.y += HUD_HEIGHT;
                if (p.minY !== undefined) p.minY += HUD_HEIGHT;
                if (p.maxY !== undefined) p.maxY += HUD_HEIGHT;
                return p;
            }
        });

        level.items.forEach(item => { item.y += HUD_HEIGHT; });
        level.exit.y += HUD_HEIGHT;
        // Shift player start coordinates
        level.playerStart.y += HUD_HEIGHT;

        level.enemies.forEach(enemy => {
            enemy.y += HUD_HEIGHT;
            if (enemy.minY !== undefined) enemy.minY += HUD_HEIGHT;
            if (enemy.maxY !== undefined) enemy.maxY += HUD_HEIGHT;
        });


        // 2. ENFORCE PLAYER START SAFETY
        let safePlayerX = level.playerStart.x;
        let safePlayerY = level.playerStart.y;
        let isSafe = false;
       
        // Define candidate starting positions (original + slight shifts)
        const candidates = [
            { x: level.playerStart.x, y: level.playerStart.y }, // 1. Original spot
            { x: level.playerStart.x + TILE_SIZE, y: level.playerStart.y }, // 2. One tile right
            { x: level.playerStart.x - TILE_SIZE, y: level.playerStart.y }, // 3. One tile left
            { x: level.playerStart.x, y: level.playerStart.y - TILE_SIZE }, // 4. One tile up
            { x: level.playerStart.x, y: level.playerStart.y + TILE_SIZE }, // 5. One tile down
        ];

        for (const candidate of candidates) {
            let collisionFound = false;
           
            // Check distance and overlap with all enemies
            for (const enemy of level.enemies) {
                const dist = distance(candidate.x, candidate.y, enemy.x, enemy.y);
               
                // Check proximity (32px distance) OR check if the enemy tile overlaps the candidate tile
                if (dist < START_SAFE_DISTANCE ||
                    (candidate.x < enemy.x + TILE_SIZE && candidate.x + player.width > enemy.x &&
                     candidate.y < enemy.y + TILE_SIZE && candidate.y + player.height > enemy.y)) {
                   
                    collisionFound = true;
                    break;
                }
            }

            if (!collisionFound) {
                safePlayerX = candidate.x;
                safePlayerY = candidate.y;
                isSafe = true;
                break; // Found a safe spot, stop searching
            }
        }
       
        if (!isSafe) {
            console.warn("Could not find a guaranteed safe starting position. Using original (potentially unsafe) location.");
            safePlayerX = level.playerStart.x;
            safePlayerY = level.playerStart.y;
        }

        // 3. Set player state based on the determined safe position
        player.x = safePlayerX;
        player.y = safePlayerY;
        player.velX = 0;
        player.velY = 0;
        player.isDead = false;
        player.isGravityUp = false;

        updateHUD();
        gameOverMessage.classList.add('hidden');
    }

    // Restart level after Game Over
    function restartLevel() {
        player.isDead = true;
       
        setTimeout(() => {
            loadLevel(currentLevel);
            gameState = 'playing';
            gameOverMessage.classList.add('hidden');
            player.isDead = false;

            // Resume music on restart (if not muted)
            if (gameMusic && !isMusicMuted) {
                gameMusic.play().catch(e => console.warn('Audio could not be resumed on restart.'));
            }
        }, 1500);
    }

    // --- GAME LOOP & UPDATE ---

    function gameLoop(timestamp) {
        if (!gameLoopRunning) return;

        const deltaTime = (timestamp - lastTime) / (1000 / 60);
        lastTime = timestamp;

        if (gameState === 'playing' && !player.isDead) {
            update(deltaTime);
            draw();
        } else if (player.isDead || gameState === 'splash' || gameState === 'win' || gameState === 'gameOver') {
            draw();
        }

        requestAnimationFrame(gameLoop);
    }

    function update(dt) {
        const level = currentLevelData;

        // Combined Acceleration: Gyro and Keyboard
        const totalTilt = gyroTilt + keyboardTilt;

        // 1. Gravity and Movement
        const currentGravity = player.isGravityUp ? -gravity : gravity;
        player.velY += currentGravity * dt;
       
        player.accelX = totalTilt * KEYBOARD_ACCEL_FACTOR;

        player.velX += player.accelX * dt;
        player.velX *= friction;
       
        if (Math.abs(player.velX) > player.maxSpeed) {
            player.velX = Math.sign(player.velX) * player.maxSpeed;
        }
       
        player.x += player.velX;
        player.y += player.velY * dt;

        // Y Boundary Check (Death zone below game area)
        if (player.y + player.height > CANVAS_HEIGHT) {
            handleCollision(player, 'boundary');
            return;
        }

        // 2. Collisions
        player.isGrounded = false;
       
        // Moving Platforms (Level-specific)
        if (currentLevel === 3) {
             level.platforms.filter(p => typeof p === 'object' && p.w).forEach(p => {
                if (p.dx && p.minX !== undefined && p.maxX !== undefined) {
                    p.x += p.dx * dt;
                    if (p.x < p.minX) {
                        p.dx = Math.abs(p.dx);
                    } else if (p.x + p.w > p.maxX) {
                        p.dx = -Math.abs(p.dx);
                    }
                }
             });
        }


        const staticPlatforms = level.platforms.filter(p => Array.isArray(p));
        const movingPlatforms = level.platforms.filter(p => typeof p === 'object' && p.w);

        [...staticPlatforms, ...movingPlatforms].forEach(pDef => {
            const p = Array.isArray(pDef) ?
                { x: pDef[0], y: pDef[1], w: pDef[2], h: pDef[3] } :
                { x: pDef.x, y: pDef.y, w: pDef.w, h: pDef.h };

            if (player.x < p.x + p.w && player.x + player.width > p.x &&
                player.y < p.y + p.h && player.y + player.height > p.y) {

                const isFallingDown = player.velY > 0;
                const isFallingUp = player.velY < 0;
                const prevYBottom = player.y + player.height - (player.velY * dt);
                const prevYTop = player.y - (player.velY * dt);

                if (!player.isGravityUp) { // Gravity is DOWN
                    if (isFallingDown && prevYBottom <= p.y) {
                        player.y = p.y - player.height;
                        player.velY = 0;
                        player.isGrounded = true;
                        if (!Array.isArray(pDef) && pDef.dx) { player.x += pDef.dx * dt; }
                    }
                    else if (isFallingUp && prevYTop >= p.y + p.h) {
                        player.y = p.y + p.h;
                        player.velY = 0;
                    }
                } else { // Gravity is UP
                    if (isFallingUp && prevYTop >= p.y + p.h) {
                        player.y = p.y + p.h;
                        player.velY = 0;
                        player.isGrounded = true;
                        if (!Array.isArray(pDef) && pDef.dx) { player.x += pDef.dx * dt; }
                    }
                    else if (isFallingDown && prevYBottom <= p.y) {
                        player.y = p.y - p.h;
                        player.velY = 0;
                    }
                }

                // Side collisions
                const previousX = player.x - player.velX;
                if (previousX + player.width <= p.x && player.x + player.width > p.x) {
                    player.x = p.x - player.width;
                    player.velX = 0;
                } else if (previousX >= p.x + p.w && player.x < p.x + p.w) {
                    player.x = p.x + p.w;
                    player.velX = 0;
                }
            }
        });


        // 3. Item Collision
        let itemsCollected = 0;
        level.items.forEach(item => {
            if (!item.collected) {
                // Item collision is checked with TILE_SIZE (8x8 box)
                if (player.x < item.x + TILE_SIZE && player.x + player.width > item.x &&
                    player.y < item.y + TILE_SIZE && player.y + player.height > item.y) {
                    item.collected = true;
                }
            }
            if (item.collected) itemsCollected++;
        });
        updateHUD(itemsCollected);

        // 4. Enemy Update and Collision and Gyro Upspeed
        level.enemies.forEach(enemy => {
            if (!enemy.isVertical) {

                const effectiveDx = enemy.dx + (gyroTilt * ENEMY_GYRO_INFLUENCE);
                enemy.x += effectiveDx * dt * 1.5;
               
                // Boundary direction change
                if (enemy.x < enemy.minX) {
                    enemy.dx = Math.abs(enemy.dx);
                } else if (enemy.x + TILE_SIZE > enemy.maxX) {
                    enemy.dx = -Math.abs(enemy.dx);
                }
            }
            else {
                enemy.y += enemy.dy * dt * 1.5;
                if (enemy.y < enemy.minY) {
                    enemy.dy = Math.abs(enemy.dy);
                    enemy.y = enemy.minY;
                } else if (enemy.y + TILE_SIZE > enemy.maxY) {
                    enemy.dy = -Math.abs(enemy.dy);
                    enemy.y = enemy.maxY - TILE_SIZE;
                }
            }
           
            // Player-Enemy Collision (Death check)
            if (player.x < enemy.x + TILE_SIZE && player.x + player.width > enemy.x &&
                player.y < enemy.y + TILE_SIZE && player.y + player.height > enemy.y) {
                handleCollision(player, 'enemy');
            }
        });

        // 5. Exit Gate Logic
        if (itemsCollected === REQUIRED_ITEMS) {
            level.exit.open = true;
            // Exit Area Check: Collision with a 8x16 area for the exit door
            if (player.x < level.exit.x + TILE_SIZE && player.x + player.width > level.exit.x &&
                player.y < level.exit.y + TILE_SIZE * 2 && player.y + player.height > level.exit.y) {
               
                handleMusicPause();
                loadLevel(currentLevel + 1);
            }
        }
    }

    // Drawing function
    function draw() {
        // Clear only the game area (below the HUD)
        ctx.clearRect(0, HUD_HEIGHT, CANVAS_WIDTH, GAME_AREA_HEIGHT);
       
        // 1. Background
        if (assets.background && assets.background.width) {
            // Background is drawn across the entire game area (below HUD)
            ctx.drawImage(assets.background, 0, HUD_HEIGHT, CANVAS_WIDTH, GAME_AREA_HEIGHT);
        } else {
            ctx.fillStyle = '#111'; // Fallback dark background
            ctx.fillRect(0, HUD_HEIGHT, CANVAS_WIDTH, GAME_AREA_HEIGHT);
        }

        const level = currentLevelData;
        const playerColor = player.isGravityUp ? '#00ccff' : '#ffcc00'; // Blue for UP, Orange for DOWN

        // 2. Draw Platforms (Fixed position and size)
        ctx.fillStyle = '#4a4a4a'; // Dark grey for platforms
        level.platforms.forEach(pDef => {
            const p = Array.isArray(pDef) ?
                { x: pDef[0], y: pDef[1], w: pDef[2], h: pDef[3] } :
                { x: pDef.x, y: pDef.y, w: pDef.w, h: pDef.h };
           
            ctx.fillRect(p.x, p.y, p.w, p.h);
            // Draw a border for clarity (optional)
            ctx.strokeStyle = '#666';
            ctx.strokeRect(p.x, p.y, p.w, p.h);
        });

        // 3. Draw Exit Gate (Requires ALL items)
        if (level.exit.open) {
            if (assets.exit && assets.exit.width) {
                // Draw exit as 8x16 (TILE_SIZE x TILE_SIZE*2)
                ctx.drawImage(assets.exit, level.exit.x, level.exit.y, TILE_SIZE, TILE_SIZE * 2);
            } else {
                ctx.fillStyle = '#00ff00'; // Green fallback
                ctx.fillRect(level.exit.x, level.exit.y, TILE_SIZE, TILE_SIZE * 2);
            }
        } else {
            // Draw a closed gate (red)
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(level.exit.x, level.exit.y, TILE_SIZE, TILE_SIZE * 2);
        }

        // 4. Draw Items (8x8 box)
        level.items.forEach(item => {
            if (!item.collected) {
                if (assets.item && assets.item.width) {
                    ctx.drawImage(assets.item, item.x, item.y, TILE_SIZE, TILE_SIZE);
                } else {
                    ctx.fillStyle = '#ffff00'; // Yellow fallback
                    ctx.fillRect(item.x, item.y, TILE_SIZE, TILE_SIZE);
                }
            }
        });

        // 5. Draw Enemies (8x8 box)
        level.enemies.forEach(enemy => {
            if (assets.enemy && assets.enemy.width) {
                ctx.drawImage(assets.enemy, enemy.x, enemy.y, TILE_SIZE, TILE_SIZE);
            } else {
                ctx.fillStyle = '#ff0000'; // Red fallback
                ctx.fillRect(enemy.x, enemy.y, TILE_SIZE, TILE_SIZE);
            }
        });
       
        // 6. Draw Player (8x8 box)
        if (!player.isDead) {
            ctx.save();
            // Flip the image if gravity is up (mirrors the sprite vertically)
            if (player.isGravityUp) {
                ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
                ctx.scale(1, -1);
                ctx.translate(-(player.x + player.width / 2), -(player.y + player.height / 2));
            }

            if (assets.player && assets.player.width) {
                ctx.drawImage(assets.player, player.x, player.y, player.width, player.height);
            } else {
                ctx.fillStyle = playerColor; // Fallback
                ctx.fillRect(player.x, player.y, player.width, player.height);
            }
            ctx.restore();
        }
    }


    // --- CONTROL HANDLERS ---

    // Toggle gravity (jump/flip)
    function flipGravity() {
        if (gameState !== 'playing' || player.isDead) return;

        player.isGravityUp = !player.isGravityUp;
        player.isGrounded = false; // Reset grounded state on flip
        playFlipTune();
        updateHUD();
    }

    // Keyboard controls for testing
    document.addEventListener('keydown', (e) => {
        if (gameState !== 'playing') return;

        if (e.key === ' ' || e.key === 'ArrowUp' || e.key === 'w') {
            flipGravity();
            e.preventDefault(); // Prevent scroll/default browser behavior
        }
        if (e.key === 'ArrowLeft' || e.key === 'a') {
            keyboardTilt = -MAX_TILT_DEGREE;
        }
        if (e.key === 'ArrowRight' || e.key === 'd') {
            keyboardTilt = MAX_TILT_DEGREE;
        }
    });

    document.addEventListener('keyup', (e) => {
        if (gameState !== 'playing') return;

        if (e.key === 'ArrowLeft' || e.key === 'a') {
            keyboardTilt = 0;
        }
        if (e.key === 'ArrowRight' || e.key === 'd') {
            keyboardTilt = 0;
        }
    });

    // Touch/Mouse control for gravity flip
    canvas.addEventListener('click', flipGravity);


    // Gyroscope control (Standard HTML5 DeviceOrientationEvent)
    if (window.DeviceOrientationEvent) {
        window.addEventListener('deviceorientation', function(event) {
            // event.gamma is the front-to-back tilt, in degrees, in the range [-90,90]
            if (event.gamma !== null) {
                // Map the gamma value to a tilt factor between -MAX_TILT_DEGREE and MAX_TILT_DEGREE
                gyroTilt = Math.max(-MAX_TILT_DEGREE, Math.min(MAX_TILT_DEGREE, event.gamma));
            }
        }, true);
    } else {
        console.log("DeviceOrientationEvent is not supported on this device.");
    }


    // --- GAME STATE MANAGEMENT ---

    function updateHUD(itemsCollected = 0) {
        const levelTitle = currentLevelData.title || `Room ${currentLevel + 1}`;
        hudLevel.textContent = `LEVEL ${currentLevel + 1}: ${levelTitle}`;
        const gravityDirection = player.isGravityUp ? 'UP' : 'DOWN';
        hudItems.textContent = `G: ${gravityDirection} | KEY: ${itemsCollected}/${REQUIRED_ITEMS}`;
    }

    function handleCollision(entity, type) {
        if (entity === player && !player.isDead) {
            player.isDead = true;
            handleMusicPause();
            gameOverMessage.classList.remove('hidden');
            gameState = 'gameOver';
            restartLevel();
        }
    }

    function handleMusicPlay() {
        if (gameMusic && !isMusicMuted) {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
            gameMusic.play().catch(e => console.warn('Audio could not be started.'));
        }
    }

    function handleMusicPause() {
        if (gameMusic) {
            gameMusic.pause();
        }
    }

    function startGame() {
        if (gameState !== 'splash') return;
       
        splashScreen.classList.add('hidden');
        gameState = 'playing';
        handleMusicPlay();
        loadLevel(0);
       
        if (!gameLoopRunning) {
            gameLoopRunning = true;
            requestAnimationFrame(gameLoop);
        }
    }

    function showEndScreen() {
        gameState = 'win';
        endScreen.classList.remove('hidden');
        handleMusicPause();
    }


    // --- INITIALIZATION ---
    document.addEventListener('DOMContentLoaded', () => {
        // Initial setup for player size
        player.width = TILE_SIZE;
        player.height = TILE_SIZE;
        loadAssets();
    });

    // Make functions globally accessible for HTML attributes
    window.toggleMusic = toggleMusic;
    window.startGame = startGame;
</script>

</body>
</html>
