<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
   <title>GRAV1TY MAN</title>
   <script src="https://cdn.tailwindcss.com"></script>
   <style>
       /* Gravity-Man CSS - Rabbit r1 Pure Viewport Mode */
       * {
           margin: 0;
           padding: 0;
           box-sizing: border-box;
       }


       body, html {
           /* Fixed dimensions for the r1 view (240x282) */
           width: 240px;
           height: 282px;
           margin: 0;
           padding: 0;
           overflow: hidden;
           background: #000;
           touch-action: none;
           font-family: 'Press Start 2P', monospace;
       }


       @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');


       #game-container {
           width: 240px;
           height: 282px;
           position: relative;
           box-shadow: none;
           border: none;
           overflow: hidden;
       }


       /* HUD Styling: with central music button */
       #hud {
           position: absolute;
           top: 0;
           left: 0;
           width: 100%;
           height: 16px;
           padding: 2px;
           color: #ff6600; /* Rabbit r1 Orange */
           background: rgba(0, 0, 0, 0.9);
           font-size: 0.4rem;
           display: flex;
           justify-content: space-between; /* Distributes the three elements */
           align-items: center;
           z-index: 100;
           border-bottom: 1px solid #ff6600;
       }
      
       #hud-music {
           cursor: pointer;
           line-height: 1;
           text-align: center;
           user-select: none;
           /* Small container for the SVG */
           width: 16px;
           height: 16px;
           display: flex;
           align-items: center;
           justify-content: center;
       }
      
       /* Ensure the SVG is small and styled */
       #music-icon {
           width: 12px;
           height: 12px;
           stroke: #ff6600;
       }


       #gameCanvas {
           display: block;
           width: 240px;
           height: 282px;
           margin: 0;
           padding: 0;
           border: none;
           position: absolute;
           top: 0;
           left: 0;
           image-rendering: pixelated;
           image-rendering: -moz-crisp-edges;
           image-rendering: crisp-edges;
       }


       /* Overlay Styles */
       .game-overlay {
           position: absolute;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           background-color: rgba(0, 0, 0, 0.95);
           color: white;
           display: flex;
           flex-direction: column;
           align-items: center;
           text-align: center;
           z-index: 150;
       }


       /* Default positioning for splash/end/loading: pushed down by HUD, centered on content top */
       #splash-screen, #end-screen, #loading-screen {
           height: calc(100% - 16px);
           top: 16px;
           justify-content: flex-start;
           padding-top: 40px;
       }


       /* Specific positioning for GAME OVER: centered in the game area */
       #game-over-message {
           height: calc(100% - 16px);
           top: 16px;
           justify-content: center; /* Centers vertically in the game area */
           padding-top: 0;
       }
      
       .overlay-title {
           font-size: 0.8rem;
           margin-bottom: 0.5rem;
           text-shadow: 0 0 4px white;
       }
      
       /* Game Over Title Color - Rabbit Orange */
       #game-over-message .overlay-title {
           color: #ff6600;
           text-shadow: 0 0 10px rgba(255, 102, 0, 0.8), 0 0 2px #ff6600;
       }




       .overlay-text {
           font-size: 0.5rem;
           margin-top: 0.5rem;
           cursor: pointer;
           animation: blink 1s step-end infinite;
       }


       @keyframes blink {
           50% { opacity: 0.1; }
       }
   </style>
</head>
<body>


<div id="game-container">
      <audio id="game-music" src="https://raw.githubusercontent.com/atomlabor/grav1ty-man-v2/main/Pixel_Dreamers.mp3" loop preload="auto"></audio>


   <div id="hud">
       <div id="hud-level">LEVEL 1: Start</div>
      
              <div id="hud-music" onclick="toggleMusic()">
           <svg id="music-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="#ff6600" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="w-3 h-3">
                              <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                              <path id="sound-waves" d="M15.54 8.46a5 5 0 0 1 0 7.07M19.07 4.93a10 10 0 1 0 0 14.14"></path>
                              <line id="mute-slash" x1="1" y1="23" x2="23" y2="1" style="display:none;"></line>
           </svg>
       </div>
      
       <div id="hud-items">G: DOWN | KEY: 0/8</div>
   </div>
  
   <canvas id="gameCanvas" width="240" height="282"></canvas>
  
   <div id="loading-screen" class="game-overlay">
       <div class="overlay-title">LOADING GAME...</div>
       <div id="loading-progress" class="text-white text-xs mt-2">0%</div>
   </div>


      <div id="splash-screen" class="game-overlay hidden" onclick="startGame()">
       <img id="splash-img" src="https://raw.githubusercontent.com/atomlabor/grav1ty-man-v2/main/grav1tyman-splash.png" class="w-1/2 h-auto mb-4">
      
       <div class="text-white text-[0.6rem] mt-4 mb-4 text-center leading-tight">
           tilt to move. tap to flip gravity. collect 8 key parts across 5 rooms to fix your starship.
       </div>
      
       <div class="overlay-text">TAP TO START</div>
   </div>


   <div id="end-screen" class="game-overlay hidden">
       <img id="end-img" src="https://raw.githubusercontent.com/atomlabor/grav1ty-man-v2/main/endscreen.png" alt="End Screen" class="w-1/2 h-auto mb-4">
       <div class="overlay-title">MISSION COMPLETE!</div>
       <div class="text-white text-xs mt-2">your starship is fixed</div>
       <div class="overlay-text" onclick="location.reload()">PLAY AGAIN</div>
   </div>


   <div id="game-over-message" class="game-overlay hidden">
       <div class="overlay-title">TRY AGAIN!</div>
       <div class="text-white text-xs mt-2">restarting shortly...</div>
   </div>


</div>


<script>
   // --- CONFIGURATION & STATE ---
   const CANVAS_WIDTH = 240;
   const CANVAS_HEIGHT = 282;
   const HUD_HEIGHT = 16;    
   const GAME_AREA_HEIGHT = CANVAS_HEIGHT - HUD_HEIGHT;
  
   const NUM_LEVELS = 5; // Total number of levels
   const REQUIRED_ITEMS = 8;
   const TILE_SIZE = 16; // NEU: Größe verdoppelt von 8 auf 16
  
   const START_SAFE_DISTANCE = 64; // Player must start at least 64px (8 tiles) away from any enemy


   let gameState = 'loading';
   let currentLevel = 0;
   let lastTime = 0;
   let gameLoopRunning = false;


   // Gyro & Keyboard State
   let gyroTilt = 0; // Wichtig: Wird durch das Gyroskop (r1-Hardware) gesetzt.
   let keyboardTilt = 0;
   const MAX_TILT_DEGREE = 20;
   const KEYBOARD_ACCEL_FACTOR = 0.5;
  
   // HÖHERER WERT: Gegner reagieren stärker auf die Neigung des Geräts.
   const ENEMY_GYRO_INFLUENCE = 1.5;
  
   let isMusicMuted = false; // State for music control


   // Game Objects
   const player = {
       x: TILE_SIZE, y: TILE_SIZE * 5, width: TILE_SIZE, height: TILE_SIZE, // NEU: width/height sind TILE_SIZE
       velX: 0, velY: 0,
       accelX: 0,
       maxSpeed: 3,
       isGrounded: false,
       isDead: false,
       isGravityUp: false
   };


   const gravity = 0.3;
   const friction = 0.8;




   // DOM Elements
   const canvas = document.getElementById('gameCanvas');
   const ctx = canvas.getContext('2d');
   const loadingScreen = document.getElementById('loading-screen');
   const loadingProgress = document.getElementById('loading-progress');
   const splashScreen = document.getElementById('splash-screen');
   const endScreen = document.getElementById('end-screen');
   const gameOverMessage = document.getElementById('game-over-message');
   const hudLevel = document.getElementById('hud-level');
   const hudItems = document.getElementById('hud-items');
   const hudMusic = document.getElementById('hud-music');
  
   // SVG Elements for Music Toggle
   let soundWaves, muteSlash;


   const splashImg = document.getElementById('splash-img');
   const endImg = document.getElementById('end-img');
  
   // Assets and Audio
   const assets = {};
   const assetUrls = {
       player: 'https://raw.githubusercontent.com/atomlabor/grav1ty-man-v2/main/grav1tyman-player.png',
       background: 'https://raw.githubusercontent.com/atomlabor/grav1ty-man-v2/main/spaceship-bg.png',
       enemy: 'https://raw.githubusercontent.com/atomlabor/grav1ty-man-v2/main/dalek.png',
       item: 'https://raw.githubusercontent.com/atomlabor/grav1ty-man-v2/main/keycard.png',
       exit: 'https://raw.githubusercontent.com/atomlabor/grav1ty-man-v2/main/exit.png',
       splash: 'https://raw.githubusercontent.com/atomlabor/grav1ty-man-v2/main/grav1tyman-splash.png',
       end: 'https://raw.githubusercontent.com/atomlabor/grav1ty-man-v2/main/endscreen.png'
   };
   let audioContext, oscillator;
   let gameMusic;


   // --- LEVEL DEFINITIONS ---
  
   // HINWEIS: Alle Koordinaten und Längen/Breiten in den Level-Daten wurden verdoppelt (x2),
   // da TILE_SIZE von 8 auf 16 erhöht wurde.

   const originalLevelData = [
       // Level 1: Beginner's Trap (Bottom Start)
       {
           platforms: [
               [0, 258*2, 240*2, TILE_SIZE], // Floor (Y=516)
               [0, 0, TILE_SIZE, 266*2], // Left Wall (Height 532)
               [232*2, 0, TILE_SIZE, 266*2], // Right Wall (Height 532, X=464)
              
               // Platforms
               [80*2, 184*2, 80*2, TILE_SIZE],
               [160*2, 184*2, 72*2, TILE_SIZE],
               [0, 124*2, 150*2, TILE_SIZE],
               [180*2, 64*2, 52*2, TILE_SIZE],
               [40*2, 64*2, 100*2, TILE_SIZE],
               [0, 4*2, 40*2, TILE_SIZE] // Exit Platform (Y=8)
           ],
           items: [
               { x: 10*2, y: 250*2, collected: false }, { x: 220*2, y: 250*2, collected: false },
               { x: 10*2, y: 176*2, collected: false }, { x: 220*2, y: 176*2, collected: false },
               { x: 10*2, y: 116*2, collected: false }, { x: 160*2, y: 116*2, collected: false },
               { x: 10*2, y: 56*2, collected: false }, { x: 220*2, y: 56*2, collected: false }
           ],
           enemies: [
               { x: 90*2, y: 176*2, dx: 0.8, minX: 80*2, maxX: 152*2, minY: 0, isVertical: false, initialX: 90*2, initialY: 176*2 }
           ],
           exit: { x: 10*2, y: 0, open: false },
           playerStart: { x: 120*2, y: 250*2 }, // START BOTTOM
           title: "Beginner's Trap"
       },
       // Level 2: Vertical Drop (Bottom Start)
       {
           platforms: [
               [0, 258*2, 240*2, TILE_SIZE],
               [0, 0, TILE_SIZE, 266*2],
               [232*2, 0, TILE_SIZE, 266*2],
              
               [40*2, 204*2, 160*2, TILE_SIZE],
               [40*2, 144*2, 160*2, TILE_SIZE],
               [40*2, 84*2, 160*2, TILE_SIZE],
              
               [210*2, 0, 22*2, TILE_SIZE],
           ],
           items: [
               { x: 20*2, y: 250*2, collected: false }, { x: 220*2, y: 250*2, collected: false },
               { x: 210*2, y: 196*2, collected: false }, { x: 50*2, y: 136*2, collected: false },
               { x: 210*2, y: 76*2, collected: false }, { x: 50*2, y: 4*2, collected: false },
               { x: 10*2, y: 136*2, collected: false }, { x: 220*2, y: 4*2, collected: false }
           ],
           enemies: [
               { x: 120*2, y: 184*2, dy: 1.2, minY: 94*2, maxY: 194*2, isVertical: true, initialY: 184*2, initialX: 120*2 },
               { x: 10*2, y: 250*2, dx: 1.5, minX: 8*2, maxX: 232*2, minY: 0, isVertical: false, initialX: 10*2, initialY: 250*2 }
           ],
           exit: { x: 210*2, y: 5*2, open: false },
           playerStart: { x: 120*2, y: 250*2 }, // START BOTTOM
           title: "Vertical Drop"
       },
       // Level 3: Central Shaft (Bottom Start) - FIXED FOR FLOW
       {
           platforms: [
               [0, 258*2, 240*2, TILE_SIZE], // Floor
               [0, 0, TILE_SIZE, 266*2], // Left Wall
               [232*2, 0, TILE_SIZE, 266*2], // Right Wall
              
               // Platform 1 (Y=204): Lower split, 20px wide central gap
               [0, 204*2, 110*2, TILE_SIZE], [130*2, 204*2, 110*2, TILE_SIZE],
              
               // Platform 2 (Y=144): Mid split, 20px wide central gap
               [0, 144*2, 110*2, TILE_SIZE], [130*2, 144*2, 110*2, TILE_SIZE],
              
               // Platform 3 (Y=84): Upper split, 20px wide central gap
               [0, 84*2, 110*2, TILE_SIZE], [130*2, 84*2, 110*2, TILE_SIZE],
              
               // Small platforms at the very top for item placement
               [50*2, -4*2, 30*2, TILE_SIZE],
               [160*2, -4*2, 30*2, TILE_SIZE],
           ],
           items: [
               { x: 10*2, y: 250*2, collected: false }, { x: 220*2, y: 250*2, collected: false }, // Floor
               { x: 120*2, y: 196*2, collected: false }, // Above P1 gap
               { x: 120*2, y: 136*2, collected: false }, // Above P2 gap 
               { x: 10*2, y: 136*2, collected: false }, { x: 220*2, y: 136*2, collected: false }, // P2 side items
               { x: 120*2, y: 76*2, collected: false }, // Above P3 gap
               { x: 60*2, y: 4*2, collected: false }, // Top left platform
               { x: 170*2, y: 4*2, collected: false } // Top right platform
           ],
           enemies: [
               { x: 25*2, y: 250*2, dx: 0.5, minX: 10*2, maxX: 220*2, minY: 0, isVertical: false, initialX: 10*2, initialY: 250*2 },
               // Vertical enemy in the central shaft
               { x: 115*2, y: 134*2, dy: 1.5, minY: 94*2, maxY: 194*2, isVertical: true, initialY: 194*2, initialX: 115*2 }
           ],
           exit: { x: 115*2, y: 0, open: false }, // Central exit, accessible from the top gap
           playerStart: { x: 220*2, y: 220*2 },
           title: "Central Shaft"
       },
       // Level 4: Ceiling Start (Non-standard Start Position)
       {
           platforms: [
               [0, 258*2, 240*2, TILE_SIZE], // Floor
               [0, 0, TILE_SIZE, 266*2], // Left Wall
               [232*2, 0, TILE_SIZE, 266*2], // Right Wall
              
               [40*2, 50*2, 80*2, TILE_SIZE], // Start Platform (around y=100)
               [160*2, 100*2, 72*2, TILE_SIZE],
               [0, 150*2, 100*2, TILE_SIZE],
               [130*2, 200*2, 50*2, TILE_SIZE]
           ],
           items: [
               { x: 10*2, y: 250*2, collected: false }, { x: 220*2, y: 250*2, collected: false },
               { x: 10*2, y: 192*2, collected: false }, { x: 170*2, y: 192*2, collected: false },
               { x: 10*2, y: 42*2, collected: false }, { x: 160*2, y: 92*2, collected: false },
               { x: 10*2, y: 142*2, collected: false }, { x: 220*2, y: 142*2, collected: false }
           ],
           enemies: [
               // Vertical enemy moving far below the start point
               { x: 120*2, y: 240*2, dy: 1.5, minY: 150*2, maxY: 250*2, isVertical: true, initialY: 240*2, initialX: 120*2 }
           ],
           exit: { x: 220*2, y: 4*2, open: false },
           playerStart: { x: 60*2, y: 42*2 }, // START NEAR CEILING
           title: "Ceiling Start"
       },
       // Level 5: Middle Start (Non-standard Start Position)
       {
           platforms: [
               [0, 258*2, 240*2, TILE_SIZE], // Floor
               [0, 0, TILE_SIZE, 266*2], // Left Wall
               [232*2, 0, TILE_SIZE, 266*2], // Right Wall
              
               [0, 160*2, 220*2, TILE_SIZE], // Wide middle platform (y=320)
               [50*2, 100*2, 140*2, TILE_SIZE],
               [10*2, 40*2, 220*2, TILE_SIZE]
           ],
           items: [
               { x: 10*2, y: 250*2, collected: false }, { x: 220*2, y: 250*2, collected: false },
               { x: 10*2, y: 152*2, collected: false }, { x: 220*2, y: 152*2, collected: false },
               { x: 10*2, y: 92*2, collected: false }, { x: 220*2, y: 92*2, collected: false },
               { x: 10*2, y: 32*2, collected: false }, { x: 220*2, y: 32*2, collected: false }
           ],
           enemies: [
               // Horizontal enemy on the middle platform
               { x: 10*2, y: 152*2, dx: 1, minX: 10*2, maxX: 220*2, minY: 0, isVertical: false, initialX: 10*2, initialY: 152*2 },
               // Vertical enemy above the start point
               { x: 120*2, y: 92*2, dy: 1, minY: 50*2, maxY: 140*2, isVertical: true, initialY: 92*2, initialX: 120*2 }
           ],
           exit: { x: 120*2, y: 4*2, open: false },
           playerStart: { x: 120*2, y: 152*2 }, // START MIDDLE
           title: "Middle Start"
       }
   ];


   let currentLevelData = [];


   // --- FUNCTIONS ---
  
   // Utility function for distance calculation
   function distance(x1, y1, x2, y2) {
       return Math.hypot(x2 - x1, y2 - y1);
   }


   // Asset Loading
   function loadAssets() {
       const totalAssets = Object.keys(assetUrls).length;
       let loadedCount = 0;
      
       soundWaves = document.getElementById('sound-waves');
       muteSlash = document.getElementById('mute-slash');
      
       const handleAssetLoad = (key, img) => {
           assets[key] = img;
           loadedCount++;
           loadingProgress.textContent = `${Math.round((loadedCount / totalAssets) * 100)}%`;
          
           if (loadedCount === totalAssets) {
               setupAudio();
              
               if (!assets.splash.isFallback) splashImg.src = assets.splash.src;
               if (!assets.end.isFallback) endImg.src = assets.end.src;
              
               loadingScreen.classList.add('hidden');
               splashScreen.classList.remove('hidden');
               gameState = 'splash';
              
            
               if (isMusicMuted) {
                   soundWaves.style.display = 'none';
                   muteSlash.style.display = 'block';
               } else {
                   soundWaves.style.display = 'block';
                   muteSlash.style.display = 'none';
               }
           }
       };


       for (const key in assetUrls) {
           const img = new Image();
           img.crossOrigin = 'anonymous';
           img.onload = () => handleAssetLoad(key, img);
           img.onerror = () => {
               console.error(`Error loading asset: ${assetUrls[key]}. Using fallback.`);
               assets[key] = { src: assetUrls[key], isFallback: true };
               handleAssetLoad(key, img);
           };
           img.src = assetUrls[key];
       }
   }
  
   // Audio Setup
   const flipTune = [1000, 1500];
   const noteDuration = 100;
  
   function setupAudio() {
       try {
           audioContext = new (window.AudioContext || window.webkitAudioContext)();
       } catch (e) {
           console.warn('Web Audio API is not supported.');
       }
       gameMusic = document.getElementById('game-music');
   }


   function playNote(freq) {
       if (!audioContext || audioContext.state === 'suspended' || isMusicMuted) return;
       let oscillator = audioContext.createOscillator();
       const gainNode = audioContext.createGain();


       oscillator.type = 'square';
       oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);


       gainNode.gain.setValueAtTime(0, audioContext.currentTime);
       gainNode.gain.linearRampToValueAtTime(0.5, audioContext.currentTime + 0.01);
       gainNode.gain.linearRampToValueAtTime(0.0, audioContext.currentTime + (noteDuration / 1000));


       oscillator.connect(gainNode);
       gainNode.connect(audioContext.destination);


       oscillator.start();
       oscillator.stop(audioContext.currentTime + (noteDuration / 1000));
   }
  
   function playFlipTune() {
       if (isMusicMuted) return; // No sound effect if muted
       if (!audioContext || audioContext.state === 'suspended') return;
       flipTune.forEach((freq, index) => {
           setTimeout(() => playNote(freq), index * 50);
       });
   }


   // Toggle music mute/play state
   function toggleMusic() {
       if (!gameMusic) return;


       isMusicMuted = !isMusicMuted;
      
       if (isMusicMuted) {
           gameMusic.pause();
           // Update SVG: Hide waves, show slash
           if (soundWaves) soundWaves.style.display = 'none';
           if (muteSlash) muteSlash.style.display = 'block';
       } else {
           // Only attempt to play if the game is active (not on splash)
           if (gameState !== 'splash') {
               // This ensures play() is called after a user interaction
               gameMusic.play().catch(e => console.warn('Audio could not be started.'));
           }
           // Update SVG: Show waves, hide slash
           if (soundWaves) soundWaves.style.display = 'block';
           if (muteSlash) muteSlash.style.display = 'none';
       }
   }
  
   // Level Logic
   function loadLevel(levelIndex) {
       currentLevel = levelIndex;
       if (currentLevel >= NUM_LEVELS) {
           showEndScreen();
           return;
       }
      
       const original = originalLevelData[currentLevel];
       // Deep clone to ensure enemies/items reset properly
       let level = JSON.parse(JSON.stringify(original));
       currentLevelData = level;


       // ADD MANDATORY TOP BOUNDARY (CEILING)
       level.platforms.push([0, 0, CANVAS_WIDTH * 2, TILE_SIZE]); // Skaliert auf 480px Breite


       // 1. Apply vertical shift (HUD_HEIGHT) to all game elements
       // HINWEIS: HUD_HEIGHT bleibt 16px, da es sich auf das 240x282 Canvas bezieht.
       // Die Koordinaten im Level sind doppelt so groß, also muss der Offset auch verdoppelt werden.
       const SCALED_HUD_HEIGHT = HUD_HEIGHT * 2; 

       level.platforms = level.platforms.map(p => {
           if (Array.isArray(p)) {
               return [p[0], p[1] + SCALED_HUD_HEIGHT, p[2], p[3]];
           } else {
               p.y += SCALED_HUD_HEIGHT;
               if (p.minY !== undefined) p.minY += SCALED_HUD_HEIGHT;
               if (p.maxY !== undefined) p.maxY += SCALED_HUD_HEIGHT;
               return p;
           }
       });


       level.items.forEach(item => { item.y += SCALED_HUD_HEIGHT; });
       level.exit.y += SCALED_HUD_HEIGHT;
       // Shift player start coordinates
       level.playerStart.y += SCALED_HUD_HEIGHT;


       level.enemies.forEach(enemy => {
           enemy.y += SCALED_HUD_HEIGHT;
           if (enemy.minY !== undefined) enemy.minY += SCALED_HUD_HEIGHT;
           if (enemy.maxY !== undefined) enemy.maxY += SCALED_HUD_HEIGHT;
       });




       // 2. ENFORCE PLAYER START SAFETY
       let safePlayerX = level.playerStart.x;
       let safePlayerY = level.playerStart.y;
       let isSafe = false;
      
       // Define candidate starting positions (original + slight shifts)
       const candidates = [
           { x: level.playerStart.x, y: level.playerStart.y }, // 1. Original spot
           { x: level.playerStart.x + TILE_SIZE, y: level.playerStart.y }, // 2. One tile right
           { x: level.playerStart.x - TILE_SIZE, y: level.playerStart.y }, // 3. One tile left
           { x: level.playerStart.x, y: level.playerStart.y - TILE_SIZE }, // 4. One tile up
           { x: level.playerStart.x, y: level.playerStart.y + TILE_SIZE }, // 5. One tile down
       ];


       for (const candidate of candidates) {
           let collisionFound = false;
          
           // Check distance and overlap with all enemies
           for (const enemy of level.enemies) {
               // Skalierter Abstand (START_SAFE_DISTANCE * 2) wäre genauer, aber 64 ist hier OK
               const dist = distance(candidate.x, candidate.y, enemy.x, enemy.y);
              
               // Check proximity (64px distance) OR check if the enemy tile overlaps the candidate tile
               if (dist < START_SAFE_DISTANCE * 2 || // NEU: Abstand * 2
                   (candidate.x < enemy.x + TILE_SIZE && candidate.x + player.width > enemy.x &&
                    candidate.y < enemy.y + TILE_SIZE && candidate.y + player.height > enemy.y)) {
                  
                   collisionFound = true;
                   break;
               }
           }


           if (!collisionFound) {
               safePlayerX = candidate.x;
               safePlayerY = candidate.y;
               isSafe = true;
               break; // Found a safe spot, stop searching
           }
       }
      
       if (!isSafe) {
           console.warn("Could not find a guaranteed safe starting position. Using original (potentially unsafe) location.");
           safePlayerX = level.playerStart.x;
           safePlayerY = level.playerStart.y;
       }


       // 3. Set player state based on the determined safe position
       player.x = safePlayerX;
       player.y = safePlayerY;
       player.velX = 0;
       player.velY = 0;
       player.isDead = false;
       player.isGravityUp = false;


       updateHUD();
       gameOverMessage.classList.add('hidden');
   }


   // Restart level after Game Over
   function restartLevel() {
       player.isDead = true;
      
       setTimeout(() => {
           loadLevel(currentLevel);
           gameState = 'playing';
           gameOverMessage.classList.add('hidden');
           player.isDead = false;


           // Resume music on restart (if not muted)
           if (gameMusic && !isMusicMuted) {
               gameMusic.play().catch(e => console.warn('Audio could not be resumed on restart.'));
           }
       }, 1500);
   }


   // --- GAME LOOP & UPDATE ---

   function gameLoop(timestamp) {
       if (!gameLoopRunning) return;


       const deltaTime = (timestamp - lastTime) / (1000 / 60);
       lastTime = timestamp;


       if (gameState === 'playing' && !player.isDead) {
           update(deltaTime);
           draw();
       } else if (player.isDead || gameState === 'splash' || gameState === 'win' || gameState === 'gameOver') {
           draw();
       }


       requestAnimationFrame(gameLoop);
   }


   function update(dt) {
       const level = currentLevelData;


       // Combined Acceleration: Gyro and Keyboard
       const totalTilt = gyroTilt + keyboardTilt;


       // 1. Gravity and Movement
       const currentGravity = player.isGravityUp ? -gravity : gravity;
       player.velY += currentGravity * dt;
      
       player.accelX = totalTilt * KEYBOARD_ACCEL_FACTOR;


       player.velX += player.accelX * dt;
       player.velX *= friction;
      
       if (Math.abs(player.velX) > player.maxSpeed) {
           player.velX = Math.sign(player.velX) * player.maxSpeed;
       }
      
       player.x += player.velX * TILE_SIZE / 8; // NEU: Geschwindigkeitsanpassung an TILE_SIZE
       player.y += player.velY * dt;


       // Y Boundary Check (Death zone below game area)
       if (player.y + player.height > CANVAS_HEIGHT * 2) { // NEU: Canvas Height * 2
           handleCollision(player, 'boundary');
           return;
       }


       // 2. Collisions
       player.isGrounded = false;
      
       // Moving Platforms (Level-specific)
       if (currentLevel === 3) {
            level.platforms.filter(p => typeof p === 'object' && p.w).forEach(p => {
               if (p.dx && p.minX !== undefined && p.maxX !== undefined) {
                   p.x += p.dx * dt;
                   if (p.x < p.minX) {
                       p.dx = Math.abs(p.dx);
                   } else if (p.x + p.w > p.maxX) {
                       p.dx = -Math.abs(p.dx);
                   }
               }
            });
       }



       const staticPlatforms = level.platforms.filter(p => Array.isArray(p));
       const movingPlatforms = level.platforms.filter(p => typeof p === 'object' && p.w);


       [...staticPlatforms, ...movingPlatforms].forEach(pDef => {
           const p = Array.isArray(pDef) ?
               { x: pDef[0], y: pDef[1], w: pDef[2], h: pDef[3] } :
               { x: pDef.x, y: pDef.y, w: pDef.w, h: pDef.h };


           if (player.x < p.x + p.w && player.x + player.width > p.x &&
               player.y < p.y + p.h && player.y + player.height > p.y) {


               const isFallingDown = player.velY > 0;
               const isFallingUp = player.velY < 0;
               const prevYBottom = player.y + player.height - (player.velY * dt);
               const prevYTop = player.y - (player.velY * dt);


               if (!player.isGravityUp) { // Gravity is DOWN
                   if (isFallingDown && prevYBottom <= p.y) {
                       player.y = p.y - player.height;
                       player.velY = 0;
                       player.isGrounded = true;
                       if (!Array.isArray(pDef) && pDef.dx) { player.x += pDef.dx * dt; }
                   }
                   else if (isFallingUp && prevYTop >= p.y + p.h) {
                       player.y = p.y + p.h;
                       player.velY = 0;
                   }
               } else { // Gravity is UP
                   if (isFallingUp && prevYTop >= p.y + p.h) {
                       player.y = p.y + p.h;
                       player.velY = 0;
                       player.isGrounded = true;
                       if (!Array.isArray(pDef) && pDef.dx) { player.x += pDef.dx * dt; }
                   }
                   else if (isFallingDown && prevYBottom <= p.y) {
                       player.y = p.y - player.height; // Korrektur: player.height anstelle von p.h
                       player.velY = 0;
                   }
               }


               // Side collisions
               const previousX = player.x - player.velX;
               if (previousX + player.width <= p.x && player.x + player.width > p.x) {
                   player.x = p.x - player.width;
                   player.velX = 0;
               } else if (previousX >= p.x + p.w && player.x < p.x + p.w) {
                   player.x = p.x + p.w;
                   player.velX = 0;
               }
           }
       });



       // 3. Item Collision
       let itemsCollected = 0;
       level.items.forEach(item => {
           if (!item.collected) {
               if (player.x < item.x + TILE_SIZE && player.x + player.width > item.x &&
                   player.y < item.y + TILE_SIZE && player.y + player.height > item.y) {
                   item.collected = true;
               }
           }
           if (item.collected) itemsCollected++;
       });
       updateHUD(itemsCollected);


       // 4. Enemy Update and Collision and Gyro Upspeed
       level.enemies.forEach(enemy => {
           if (!enemy.isVertical) {

               const effectiveDx = enemy.dx + (gyroTilt * ENEMY_GYRO_INFLUENCE);
               enemy.x += effectiveDx * dt * 1.5;
              
               // Boundary direction change
               if (enemy.x < enemy.minX) {
                   enemy.dx = Math.abs(enemy.dx);
               } else if (enemy.x + TILE_SIZE > enemy.maxX) {
                   enemy.dx = -Math.abs(enemy.dx);
               }
           }
           else {
               enemy.y += enemy.dy * dt * 1.5;
               if (enemy.y < enemy.minY) {
                   enemy.dy = Math.abs(enemy.dy);
                   enemy.y = enemy.minY;
               } else if (enemy.y + TILE_SIZE > enemy.maxY) {
                   enemy.dy = -Math.abs(enemy.dy);
                   enemy.y = enemy.maxY - TILE_SIZE;
               }
           }
          
           // Player-Enemy Collision (Death check)
           if (player.x < enemy.x + TILE_SIZE && player.x + player.width > enemy.x &&
               player.y < enemy.y + TILE_SIZE && player.y + player.height > enemy.y) {
               handleCollision(player, 'enemy');
           }
       });


       // 5. Exit Gate Logic
       if (itemsCollected === REQUIRED_ITEMS) {
           level.exit.open = true;
           // Exit Area Check
           if (player.x < level.exit.x + TILE_SIZE && player.x + player.width > level.exit.x &&
               // NEU: Exit-Bereich auf TILE_SIZE * 2 korrigiert
               player.y < level.exit.y + TILE_SIZE * 2 && player.y + player.height > level.exit.y) {
              
               handleMusicPause();
               loadLevel(currentLevel + 1);
           }
       }
   }


   // Drawing function
   function draw() {
       // Clear only the game area (below the HUD)
       ctx.clearRect(0, HUD_HEIGHT, CANVAS_WIDTH, GAME_AREA_HEIGHT);
      
       // Canvas-Skalierung für doppelte Pixelgröße (TILE_SIZE=16 auf 8 Pixel)
       const SCALE_FACTOR = 0.5; // Skaliert das 480x564 "logische" Spiel auf 240x282
       ctx.save();
       ctx.scale(SCALE_FACTOR, SCALE_FACTOR);


       // 1. Background: Draw background image starting at SCALED_HUD_HEIGHT
       const SCALED_HUD_HEIGHT = HUD_HEIGHT * 2;
       if (assets.background && !assets.background.isFallback) {
           // Hintergrund-Bild wird über den gesamten skalierten Bereich gezeichnet
           ctx.drawImage(assets.background, 0, SCALED_HUD_HEIGHT, CANVAS_WIDTH * 2, CANVAS_HEIGHT * 2 - SCALED_HUD_HEIGHT);
       } else {
           ctx.fillStyle = '#111';
           ctx.fillRect(0, SCALED_HUD_HEIGHT, CANVAS_WIDTH * 2, CANVAS_HEIGHT * 2 - SCALED_HUD_HEIGHT);
       }

       // 2. Platforms
       ctx.fillStyle = '#ff6600'; // Rabbit Orange für Plattformen
       currentLevelData.platforms.forEach(pDef => {
           if (Array.isArray(pDef)) {
               ctx.fillRect(pDef[0], pDef[1], pDef[2], pDef[3]);
           } else {
               ctx.fillRect(pDef.x, pDef.y, pDef.w, pDef.h);
           }
       });


       // 3. Items (Key Cards)
       currentLevelData.items.forEach(item => {
           if (!item.collected) {
               if (assets.item && !assets.item.isFallback) {
                   ctx.drawImage(assets.item, item.x, item.y, TILE_SIZE, TILE_SIZE);
               } else {
                   ctx.fillStyle = 'yellow';
                   ctx.fillRect(item.x, item.y, TILE_SIZE, TILE_SIZE);
               }
           }
       });


       // 4. Exit
       const exit = currentLevelData.exit;
       if (exit.open) {
           if (assets.exit && !assets.exit.isFallback) {
               // Die Tür ist TILE_SIZE * 2 hoch
               ctx.drawImage(assets.exit, exit.x, exit.y, TILE_SIZE, TILE_SIZE * 2); 
           } else {
               ctx.fillStyle = 'lime';
               ctx.fillRect(exit.x, exit.y, TILE_SIZE, TILE_SIZE * 2);
           }
       } else {
           // Geschlossene Tür
           ctx.fillStyle = 'red';
           ctx.fillRect(exit.x, exit.y, TILE_SIZE, TILE_SIZE * 2);
       }


       // 5. Enemies (Dalvik)
       currentLevelData.enemies.forEach(enemy => {
           if (assets.enemy && !assets.enemy.isFallback) {
               // NEU: Zeichne Dalvik mit TILE_SIZE x TILE_SIZE (16x16)
               ctx.drawImage(assets.enemy, enemy.x, enemy.y, TILE_SIZE, TILE_SIZE); 
           } else {
               ctx.fillStyle = 'magenta';
               ctx.fillRect(enemy.x, enemy.y, TILE_SIZE, TILE_SIZE);
           }
       });


       // 6. Player (Astronaut)
       if (!player.isDead) {
           if (assets.player && !assets.player.isFallback) {
               // NEU: Zeichne Spieler mit player.width x player.height (16x16)
               // Zusätzlich spiegeln, wenn er nach links läuft (optional)
               ctx.save();
               let flip = player.velX < 0 ? -1 : 1;
               ctx.scale(flip, 1);
               ctx.drawImage(
                   assets.player, 
                   player.x * flip - (flip === -1 ? player.width : 0), // X-Position für Flip korrigieren
                   player.y, 
                   player.width, 
                   player.height
               );
               ctx.restore();
           } else {
               ctx.fillStyle = 'cyan';
               ctx.fillRect(player.x, player.y, player.width, player.height);
           }
       }

       ctx.restore(); // Skalierung zurücksetzen

       // HUD wird unskaliert gezeichnet
       // HUD-Update findet in updateHUD statt, nur die Draw-Routine hier
   }
  
   // ... Restliche Funktionen ...

   // Start Game (Called from splash screen)
   function startGame() {
       if (gameState !== 'splash') return;
      
       gameState = 'playing';
       splashScreen.classList.add('hidden');
      
       if (audioContext && audioContext.state === 'suspended') {
           audioContext.resume().then(() => {
               if (gameMusic && !isMusicMuted) {
                   gameMusic.play().catch(e => console.warn('Audio could not be started after resume.'));
               }
           });
       } else if (gameMusic && !isMusicMuted) {
           gameMusic.play().catch(e => console.warn('Audio could not be started.'));
       }


       loadLevel(0);
       if (!gameLoopRunning) {
           gameLoopRunning = true;
           requestAnimationFrame(gameLoop);
       }
   }


   function handleMusicPause() {
       if (gameMusic) gameMusic.pause();
   }


   function showEndScreen() {
       gameState = 'win';
       handleMusicPause();
       endScreen.classList.remove('hidden');
   }


   function handleCollision(entity, type) {
       if (type === 'enemy' || type === 'boundary') {
           if (entity.isDead) return;
          
           entity.isDead = true;
           gameState = 'gameOver';
           gameOverMessage.classList.remove('hidden');
           handleMusicPause();
           restartLevel();
       }
   }


   function updateHUD(itemsCollected = 0) {
       hudLevel.textContent = `LEVEL ${currentLevel + 1}: ${currentLevelData[currentLevel]?.title || '...'} `;
       
       const gravityDirection = player.isGravityUp ? 'UP' : 'DOWN';
       hudItems.textContent = `G: ${gravityDirection} | KEY: ${itemsCollected}/${REQUIRED_ITEMS}`;
   }


   // --- EVENT HANDLERS (Gravity Flip on Tap) ---
   function handleGravityFlip() {
       if (gameState === 'playing' && !player.isDead) {
           player.isGravityUp = !player.isGravityUp;
           // Reverse vertical velocity for smooth flip
           player.velY = -player.velY * 0.5;
           playFlipTune(); // Play sound effect
       } else if (gameState === 'splash' || gameState === 'win') {
           startGame();
       }
   }


   // Touch/Click Event Listener for Gravity Flip
   document.addEventListener('click', (e) => {
       if (e.target.closest('#hud-music') || e.target.closest('.game-overlay')) {
           // Ignore clicks on HUD or overlay elements
           return;
       }
       handleGravityFlip();
   });


   // Keyboard Controls (For testing/desktop)
   document.addEventListener('keydown', (e) => {
       if (gameState === 'playing' && !player.isDead) {
           if (e.code === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
               keyboardTilt = -MAX_TILT_DEGREE;
           } else if (e.code === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
               keyboardTilt = MAX_TILT_DEGREE;
           } else if (e.code === 'Space' || e.code === 'KeyF') {
               handleGravityFlip();
           }
       } else if (gameState === 'splash' && e.code === 'Space') {
           startGame();
       }
   });


   document.addEventListener('keyup', (e) => {
       if (e.code === 'ArrowLeft' || e.key === 'a' || e.key === 'A' || e.code === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
           keyboardTilt = 0;
       }
   });


   // Start the asset loading process
   loadAssets();


</script>
</body>
</html>
